================================================================================
Anki CSV生成脚本测试报告
================================================================================

1. 卡片数量对比
--------------------------------------------------------------------------------
生成的CSV卡片数量: 292
现有的CSV卡片数量: 292
数量匹配: ✓

2. 卡片匹配情况
--------------------------------------------------------------------------------
完全匹配的卡片: 0 / 292 (0.0%)

3. 卡片差异详情
--------------------------------------------------------------------------------

卡片 #1:
  [问题不匹配]
  生成: <div style="text-align: left;">StatsD中Pushed Atom和Pulled Atom的区别是什么？</div>...
  现有: <div style="text-align: left;">在DSP算法移植项目中，为什么使用整数计算代替浮点数计算？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;"><ul><br><li>Pushed Atom（主动型）：</li><br><li>由应用主动上报事件</li><br><li>原理：应用在事件发生时立即上报，数据流是推式的（push），实时性好</li><br><li>比喻：就像快递员主动送货上门，有货就送</li><br><li>底层实现为Unix domain socket通信（...
  现有: <div style="text-align: left;">1. 提高运算速度：整数运算比浮点数运算快得多<br>   - 原理：整数运算只需要ALU（算术逻辑单元）的简单加法器，而浮点数需要复杂的IEEE 754标准处理（符号位、指数位、尾数位的分离和重组），硬件电路更复杂<br>   - 比喻：就像用计算器做整数加减法比做小数运算更快更简单<br><br>2. DSP限制：高通DSP不提供浮...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-算法移植

卡片 #2:
  [问题不匹配]
  生成: <div style="text-align: left;">StatsD中灵活结算温度区间数据的核心思路是什么？</div>...
  现有: <div style="text-align: left;">Ping-Pong Buffer在L2 Cache中的作用是什么？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;">核心思路：为每一段温度区间打上两个标签<br><br><ul><br><li>温度区间的编号：标识当前温度等级</li><br><li>原理：将连续的温度值离散化为区间（如0-30°C为区间1，30-50°C为区间2），用编号标识，简化数据处理</li><br><li>比喻：就像把温度分成几个等级（冷、温、热），用数字编号</li><b...
  现有: <div style="text-align: left;">Ping-Pong Buffer是一种双缓冲技术，在L2 Cache中交替使用两个缓冲区：<br><br>原理：<br>1. 当一个缓冲区在写入数据时，另一个缓冲区可以读取数据<br>   - 原理：通过两个独立的缓冲区实现读写分离，避免单缓冲区的读写冲突（写操作会阻塞读操作）<br>   - 比喻：就像餐厅有两个备餐台，一个在准备新菜...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-算法移植

卡片 #3:
  [问题不匹配]
  生成: <div style="text-align: left;">StatsD中Metric分为哪两类？各有什么特点？</div>...
  现有: <div style="text-align: left;">HVX指令一次可以处理多少个元素？效率提升多少？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;">第一类：结构固定的Metric（Count、Duration、Value）<br><ul><br><li>数据都是整数或浮点数</li><br><li>原理：这些Metric只包含数值，数据结构简单，可以用基本类型表示</li><br><li>比喻：就像只记录数字，格式统一</li><br><li>解析简单，结构固定</li><br><...
  现有: <div style="text-align: left;">HVX（Hexagon Vector eXtensions）一次可以处理128个元素。<br><br>原理：<br>- HVX是SIMD（单指令多数据）架构，一条指令可以同时对128个数据元素执行相同操作<br>- 原理：CPU内部有128个并行的ALU（算术逻辑单元），可以同时处理128个数据，就像128个工人同时做同样的工作<br>...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-算法移植

卡片 #4:
  [问题不匹配]
  生成: <div style="text-align: left;">Pulled Atom在累计数据流中采样时需要注意什么？</div>...
  现有: <div style="text-align: left;">L2 Cache预取需要注意哪些问题？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;"><ul><br><li>如果使用方只有一个：可以在采样后立刻重置数据，配置文件编写相对容易</li><br><li>原理：单用户场景下，采样后重置不会影响其他用户，可以简化逻辑，直接读取当前值然后清零</li><br><li>比喻：就像只有一个读者，看完书可以立即归还，不影响其他人</li><br></ul><br><br><ul><b...
  现有: <div style="text-align: left;">1. 需要提前prefetch，不能等到需要数据时再预取<br>   - 原理：预取需要时间（从DRAM到Cache需要几十到几百个时钟周期），如果等到需要时再预取，CPU会等待数据，导致流水线停顿<br>   - 比喻：就像提前准备食材，如果等客人点菜再买菜，客人要等很久；提前准备可以让上菜更快<br><br>2. 三条以上的fetc...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-算法移植

卡片 #5:
  [问题不匹配]
  生成: <div style="text-align: left;">StatsD项目中，如何处理非固定格式的埋点结算？</div>...
  现有: <div style="text-align: left;">端侧功耗大数据项目中，如何获取原始数据？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;"><ul><br><li>增加埋点field：在Atom中添加额外的字段</li><br><li>原理：Atom是StatsD的数据单元，可以包含多个字段；非固定格式需要在Atom中增加自定义字段，用于存储灵活的数据</li><br><li>比喻：就像在表格中增加新列，存储额外信息</li><br></ul><br><br><ul><br...
  现有: <div style="text-align: left;">使用两种方式获取原始数据：<br><br>1. 读节点方式：直接读取系统节点文件（如/sys/class/power_supply/battery/current_now）<br>   - 原理：Linux的sysfs文件系统将内核数据暴露为文件，通过文件I/O可以读取硬件状态（如电流、电压），这是最简单直接的方式<br>   - 比喻...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-功耗大数据

卡片 #6:
  [问题不匹配]
  生成: <div style="text-align: left;">StatsD的核心功能是什么？</div>...
  现有: <div style="text-align: left;">Display模块功耗计算为什么采用CWB截屏和白名单结合的方式？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;">StatsD是Android系统级的统计服务，主要用来收集、聚合和上报各种系统或应用的指标数据。它允许其他模块注册自己的统计需求，比如指定要收集哪些数据、用什么方式聚合（比如计数、求和、平均值），然后StatsD会按照注册时的规则去采集和处理数据。<br><br><ul><br><li>原理：StatsD是AOSP中的原生服务（nati...
  现有: <div style="text-align: left;">1. CWB（Color Wheel Buffer）截屏可以实时获取屏幕内容，计算精确但开销大<br>   - 原理：CWB是图形系统的底层接口，可以获取当前屏幕的像素数据，通过分析像素内容（亮度、颜色分布）可以精确计算显示功耗；但截屏操作需要GPU参与，会触发硬件加速，产生额外功耗<br>   - 比喻：就像用高清相机实时拍摄屏幕，能...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-功耗大数据

卡片 #7:
  [问题不匹配]
  生成: <div style="text-align: left;">APP层和Native层注册StatsD的通信方式有什么区别？</div>...
  现有: <div style="text-align: left;">功耗大数据项目从2.0到3.0阶段，架构变化的原因是什么？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;">APP层和Native层都能注册StatsD，不过通信方式确实不太一样：<br><br>APP层：<br><ul><br><li>一般会通过Android提供的Java API，比如用StatsManager类来注册</li><br><li>原理：StatsManager位于android.app包，通过StatsCompanionSe...
  现有: <div style="text-align: left;">主要原因：<br>1. 性能优化：native层执行效率更高，内存占用更少<br>2. 稳定性：减少APK进程挂掉对业务代码的影响<br>3. 业务解耦：APK可以单独发版，native侧跟随整机版本<br>4. 安全性：native层代码更难被反编译<br>5. 维护成本：去掉臃肿的JNI，配合HIDL转AIDL演进</div>...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-功耗大数据

卡片 #8:
  [问题不匹配]
  生成: <div style="text-align: left;">StatsD中什么时候使用Socket通信？</div>...
  现有: <div style="text-align: left;">在native层daemon进程中，如何使用SQLite？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;">StatsD的通信机制：<br><br>本地通信：<br><ul><br><li>Pushed Atom：使用Unix domain socket（本地IPC），不是网络socket</li><br><li>原理：根据AOSP源码，StatsD使用StatsSocketListener监听Unix domain socket接收log事...
  现有: <div style="text-align: left;">1. 使用Android Native层的sqlite3库<br>   - 原理：Android NDK提供了sqlite3的C/C++接口，可以直接在native代码中使用，无需通过JNI调用Java层<br>   - 比喻：就像直接使用本地工具库，不需要通过翻译<br><br>2. 通过自定义的C++隔离接口实现增删改查操作<br>...
  [标签不匹配] 生成: 项目经历-StatsD, 现有: 项目经历-功耗大数据

卡片 #9:
  [问题不匹配]
  生成: <div style="text-align: left;">为什么StatsD中Push Atom上报方使用Socket而不是Binder？</div>...
  现有: <div style="text-align: left;">StatsD中Pushed Atom和Pulled Atom的区别是什么？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;">StatsD中Push Atom（主动上报）使用Unix domain socket而不是Binder，这是基于AOSP源码设计和系统架构的合理选择，主要原因包括：<br><br><ul><br><li>早期启动阶段可用性：</li><br><li>Binder服务启动时机：</li><br><li>Binder驱动和ServiceMa...
  现有: <div style="text-align: left;">1. Pushed Atom（主动型）：<br>   - 由应用主动上报事件<br>     * 原理：应用在事件发生时立即上报，数据流是推式的（push），实时性好<br>     * 比喻：就像快递员主动送货上门，有货就送<br>   - 底层实现为Unix domain socket通信（本地IPC）<br>     * 原理：U...

卡片 #10:
  [问题不匹配]
  生成: <div style="text-align: left;">端侧功耗大数据项目中，如何获取原始数据？</div>...
  现有: <div style="text-align: left;">StatsD中灵活结算温度区间数据的核心思路是什么？</div>...
  [答案不匹配]
  生成: <div style="text-align: left;">使用两种方式获取原始数据：<br><br><ul><br><li>读节点方式：直接读取系统节点文件（如/sys/class/power_supply/battery/current_now）</li><br><li>原理：Linux的sysfs文件系统将内核数据暴露为文件，通过文件I/O可以读取硬件状态（如电流、电压），这是最简单直接的...
  现有: <div style="text-align: left;">核心思路：为每一段温度区间打上两个标签<br><br>1. 温度区间的编号：标识当前温度等级<br>   - 原理：将连续的温度值离散化为区间（如0-30°C为区间1，30-50°C为区间2），用编号标识，简化数据处理<br>   - 比喻：就像把温度分成几个等级（冷、温、热），用数字编号<br><br>2. 温度区间的开始时间戳：标识...
  [标签不匹配] 生成: 项目经历-功耗大数据, 现有: 项目经历-StatsD

... 还有 282 个差异未显示

4. 标签差异
--------------------------------------------------------------------------------
卡片 #1: 生成=项目经历-StatsD, 现有=项目经历-算法移植
卡片 #2: 生成=项目经历-StatsD, 现有=项目经历-算法移植
卡片 #3: 生成=项目经历-StatsD, 现有=项目经历-算法移植
卡片 #4: 生成=项目经历-StatsD, 现有=项目经历-算法移植
卡片 #5: 生成=项目经历-StatsD, 现有=项目经历-功耗大数据
卡片 #6: 生成=项目经历-StatsD, 现有=项目经历-功耗大数据
卡片 #7: 生成=项目经历-StatsD, 现有=项目经历-功耗大数据
卡片 #8: 生成=项目经历-StatsD, 现有=项目经历-功耗大数据
卡片 #10: 生成=项目经历-功耗大数据, 现有=项目经历-StatsD
卡片 #11: 生成=项目经历-功耗大数据, 现有=项目经历-StatsD
... 还有 242 个标签差异未显示

================================================================================
测试总结
================================================================================
✗ 发现差异，请检查脚本实现。
  - 有 292 张卡片存在差异
