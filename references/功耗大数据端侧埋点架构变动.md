# 功耗大数据端侧埋点架构变动

（2.0阶段 APK共进程；3.0阶段：迁移到native层）

## 简单版

2.0阶段对应Android 10，采用如下设计：

1. 将绝大部分业务逻辑用C++代码的形式放在一个APK中，跟这个APK共进程，并用JNI进行调用，节省了一部分IPC的开销
2. 为了解决数据权限问题，引入额外的native层常驻进程，提供数据接口服务

Android 11阶段，团队决定将几乎所有业务逻辑迁移到native层，在APK层只保留Java代码，接收系统事件以及部分数据。

此时，架构演变为：
- 通过AIDL接口，将事件传递给下层
- 在native层处理事件。主要工作是读取系统信息，结算功耗

## 中等版

在2.0阶段架构设计中，考虑到如下三点：

1. ColorOS中对于常驻进程，有严格的内存增量限制
2. 需要实时接收系统消息，而系统广播等事件基本都在Java层
3. 还需要跟HAL层或者驱动层交互（主要是CPU Battery和Display），然而APK层缺少必要的权限和机制

因此采用如下设计：

1. 将绝大部分业务逻辑用C++代码的形式放在一个APK中，跟这个APK共进程，并用JNI进行调用，节省了一部分IPC的开销
2. 为了解决数据权限问题，引入额外的native层常驻进程，提供数据接口服务

Android 11阶段，团队决定将几乎所有业务逻辑迁移到native层，在APK层只保留Java代码，接收系统事件以及部分数据。

此时，架构演变为：
- 通过AIDL接口，将事件传递给下层
- 在native层处理事件。主要工作是读取系统信息，结算功耗
- 读取方式是：通过AIDL调用HAL层服务或surfaceflinger等服务，或者直接读系统节点。根据需要在sepolicy中添加对应权限

这样做的好处是：

1. 性能优化，内存占用减少
2. 减少原先所在的APK进程（如：虽然常驻但仍然可能挂掉等）对业务代码的影响
3. 业务解耦，方便项目管理，例如：
   - 统一版本发布的节奏（APK可以单独发版，但native侧只能跟随整机版本）
   - 划分bug单责任或处理常驻进程内存增量的责任，等等
4. 安全性，如应对Java层反编译等（存疑）
5. 去掉臃肿且难以维护的JNI
6. 配合Android 11对HIDL转AIDL的演进，减少维护成本

## 详细版

同时，为了解决数据权限问题，需要一个额外的native层进程，不过仍然会存在HIDL AIDL域的冲突问题。因此在Android 10阶段，使用Stable AIDL方案进行版本控制和兼容性检查。

### 问题：如何解决Android 10阶段HIDL和AIDL分别属于不同的域，不能共存的问题

在Android 10阶段，HIDL和AIDL分别属于不同的SELinux域，不能共存。解决方案是使用Stable AIDL方案进行版本控制和兼容性检查，确保不同域之间的安全通信。
