# 灵活结算StatsD的报告

## 简单版

Android原生的StatsD中，只支持按固定时间段结算数据并聚合。而专项组的需求是，数据要以温度区间变化为分界点进行结算，以获得用户在一天内随手机壳温变化的使用情况。这与Android原生的设计相违背。

因此，我用一种巧妙的办法，将数据结构化存储，并整理成了需要的形式。

具体做法是：StatsD结算时允许规定聚合的维度，因此我为每一段温度区间打上两个标签：

1. 温度区间的编号
2. 温度区间的开始时间戳

这样就可以突破限制，获取随温度变化的数据。

## 中等版

Android原生的StatsD中，只支持按固定时间段结算数据并聚合。而专项组的需求是，数据要以温度区间变化为分界点进行结算，以获得用户在一天内随手机壳温变化的使用情况。这与Android原生的设计相违背。

因此，我利用现有的聚合机制，存储了结构化数据，并整理成了需要的形式。

StatsD中结算时允许规定聚合的维度。聚合的维度主要是两种：

1. 以指定事件开始和结束定义的condition，例如亮灭屏，前后台
2. 类似uid或应用版本号的数据标签

这两种维度都无法满足要求，原因在于：

1. 对于第一类维度，无法针对多达20个温度区间定义开始和结束事件
2. 对于第二类维度，如果直接按照温度区间聚合，只会看到每个温度区间结算一份数据，实际上一份数据可能是由多段数据组成，且无法区分。例如，温度等级从3到4再到3，我们希望看到这个变化过程，但直接聚合只会看到3和4两份数据

因此在原本的温度区间Atom埋点上，打上两个标签：

1. 温度区间的编号
2. 温度区间的开始时间戳

这样就可以突破限制，获取随温度变化的数据，并且得到每段温度区间变化的开始时间和结束时间。

## 详细版

在Android中，StatsD是一种用于收集和分析系统和应用程序性能数据的统计守护程序（Statistical Daemon）。它是Android的性能监控和诊断工具之一，StatsD能够从系统层面和应用层面（如系统层的logd、内核事件、应用日志等）收集事件数据。

这些数据通常是通过Atom的形式传递的。Atom是一个数据结构，用于定义需要收集的数据事件（如App启动时间、电池使用情况、内存使用情况等）。

在OPPO工作期间，我参与了以StatsD为基础进行设计的OStatsD的项目。这是另一个守护进程，它的主要功能是开机后向StatsD注册StatsD config，在日结算或故障发生时获取到报告文件，同时缓存、解析并上传。

这个项目中，我遇到的主要难点是按照专项组要求结算并聚合数据。而专项组的需求是，数据要以温度区间变化为分界点进行结算，以获得用户在一天内随手机壳温变化的使用情况。这与Android原生的设计相违背。

因此，我利用现有的聚合机制，存储了结构化数据，并整理成了需要的形式。

StatsD中结算时允许规定聚合的维度。聚合的维度主要是两种：

1. 以指定事件开始和结束定义的condition，例如亮灭屏，前后台
2. 类似uid或应用版本号的数据标签

这两种维度都无法满足要求，原因在于：

1. 对于第一类维度，无法针对多达20个温度区间定义开始和结束事件
2. 对于第二类维度，如果直接按照温度区间聚合，只会看到每个温度区间结算一份数据，实际上一份数据可能是由多段数据组成，且无法区分。例如，温度等级从3到4再到3，我们希望看到这个变化过程，但直接聚合只会看到3和4两份数据

因此在原本的温度区间Atom埋点上，打上两个标签：

1. 温度区间的编号
2. 温度区间的开始时间戳

这样就可以突破限制，获取随温度变化的数据，并且得到每段温度区间变化的开始时间和结束时间。

此外，从新增Atom到设计结算规则的全流程，也需要对StatsD的机制有一定掌握。

## 基本分类

### Atom方面

Atom分为主动型Pushed Atom和被动型Pulled Atom。这两种Atom对应事件上报以及插桩采集数据两种不同的操作，也对应了StatsD不同的统计逻辑。

### Metric方面

主要有以下几种：

- **CountMetric**：用于计算事件的总次数
- **DurationMetric**：用于统计事件的持续时间
- **ValueMetric**：用于统计特定值（如最大值、最小值、平均值等）
- **GaugeMetric**：用于测量特定时刻的指标（如电量、内存占用）
- **EventMetric**：用于记录单次事件
- **KllMetric**：用于记录分位值，如90%分位值等

此外，还有Alarm（闹钟）和Alert（报警）等。

## 本人踩坑记录

### Pulled Atom数据流统计

Pulled atom如果是在累计数据流中采样，例如统计数据流量使用情况或已刷新的屏幕帧数，还需要单独设计。如果确定使用方只有一个，可以在采样后立刻重置数据，这样可以使配置文件的编写相对容易；反之，如果有多方使用数据的情况，则只能让数据始终累加，因而需要设计数据循环或定期清零的机制，并且在配置文件中写明只统计增量，并针对重置的情况添加过滤规则。

### Metric解析

除很少使用的KllMetric外，另外5种metric分为两类。

第一类是结构固定的Count、Duration、Value三种，因为无论如何结算，它们的数据都只是一个整数或者浮点数；第二类是Gauge和Event两种，它们的结构随Atom的结构而变化，十分灵活。由于protobuf解码需要proto文件，而StatsD也就是编码端的Atoms.proto极为庞大，似乎不可能以很低的代价解码。不过在实际应用中，我采用了妥协的方案，也就是只将用到的一部分proto抄写并编译进来，解决了这个问题。
